---
title: "Using cartograms with parlitools"
author: "Evan Odell"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to parlitools}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Scaling with `cartogram`

You can use the [`cartogram`](https://CRAN.R-project.org/package=cartogram) package with `parlitools` to produce maps with scaled areas, as seen in [Xinye Li's post on Brexit votes](https://xinye1.github.io/projects/brexit-cartogram-leaflet/). 

As the cartogram package requires SpatialPolygonsDataFrame objects, instead of simple features objects, the 'west_hex_map' object is converted first to a Spatial object, and then to a SpatialPolygonsDataFrame object, as there is no function to convert directly from sf to SpatialPolygonsDataFrame.

## Scaling by seat safety

The map below shows the relative safety of each parliamentary seat, as represented by the percentage point margin between each seat's winning and second place candidate---the 'majority'---in the 2015 General Election. The larger the seat's hexagon, the safer---in theory---it is.

It uses datasets included in this package, namely the British Election Study (`bes_2015`), `party_colours` and `west_hex_map`. As the BES only covers Wales, Scotland and England, Northern Ireland is not included in the map.

```{r fig.width=6, fig.height=7, message=FALSE, warning=FALSE}

library(leaflet)
library(sf)
library(htmlwidgets)
library(dplyr)
library(hansard)
library(mnis)
library(parlitools)
library(cartogram)

west_hex_map <- parlitools::west_hex_map

party_colour <- parlitools::party_colour

elect2015 <- parlitools::bes_2015

elect2015_win_colours <- left_join(elect2015, party_colour, by = c("winner_15" ="party_name")) #Join to current MP data

gb_hex_map <- right_join(west_hex_map, elect2015_win_colours, by = c("gss_code"="onsconst_id")) #Join colours to hexagon map

gb_hex_map <- as(gb_hex_map, "Spatial")

gb_hex_map <- as(gb_hex_map, "SpatialPolygonsDataFrame")

gb_hex_map$majority_15 <- round(gb_hex_map$majority_15, 2)

gb_hex_map$turnout_15 <- round(gb_hex_map$turnout_15, 2)

gp_hex_scaled <- cartogram(gb_hex_map, 'majority_15')

# Creating map labels
labels <- paste0(
  "Constituency: ", gp_hex_scaled$constituency_name.y, "</br>",
  "Most Recent Winner: ", gp_hex_scaled$winner_15, "</br>",
  "Most Recent Majority:", gp_hex_scaled$majority_15, "%","</br>",
  "Turnout: ", gp_hex_scaled$turnout_15, "%"
) %>% lapply(htmltools::HTML)

# Creating the map itself
leaflet(options=leafletOptions(
  dragging = FALSE, zoomControl = FALSE, tap = FALSE,
  minZoom = 6, maxZoom = 6, maxBounds = list(list(2.5,-7.75),list(58.25,50.0)),
  attributionControl = FALSE),
  gp_hex_scaled) %>%
  addPolygons(
    color = "grey",
    weight=0.75,
    opacity = 0.5,
    fillOpacity = 1,
    fillColor = ~party_colour,
    label=labels)  %>%
  htmlwidgets::onRender(
    "function(x, y) {
        var myMap = this;
        myMap._container.style['background'] = '#fff';
    }")%>%
  mapOptions(zoomToLimits = "first")
```


## Scaling by marginality

This map scales constituencies based on how marginal they are, by subtracting the majority from 100 and squaring that value. Larger constituencies are those deemed to be more marginal.

```{r fig.width=6, fig.height=7, message=FALSE, warning=FALSE}

gb_hex_map$marginality <- (100-gb_hex_map$majority_15)^2

gp_hex_scaled <- cartogram(gb_hex_map, 'marginality')

# Creating map labels
labels <- paste0(
  "Constituency: ", gp_hex_scaled$constituency_name.y, "</br>",
  "Most Recent Winner: ", gp_hex_scaled$winner_15, "</br>",
  "Most Recent Majority: ", gp_hex_scaled$majority_15, "%","</br>",
  "Turnout: ", gp_hex_scaled$turnout_15, "%"
) %>% lapply(htmltools::HTML)

# Creating the map itself
leaflet(options=leafletOptions(
  dragging = FALSE, zoomControl = FALSE, tap = FALSE,
  minZoom = 6, maxZoom = 6, maxBounds = list(list(2.5,-7.75),list(58.25,50.0)),
  attributionControl = FALSE),
  gp_hex_scaled) %>%
  addPolygons(
    color = "grey",
    weight=0.75,
    opacity = 0.5,
    fillOpacity = 1,
    fillColor = ~party_colour,
    label=labels) %>% 
  htmlwidgets::onRender(
    "function(x, y) {
        var myMap = this;
        myMap._container.style['background'] = '#fff';
    }")%>% 
  mapOptions(zoomToLimits = "first")

```

